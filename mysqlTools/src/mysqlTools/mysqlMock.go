// Code generated by MockGen. DO NOT EDIT.
// Source: mysqlTools (interfaces: MysqlTools)

// Package mysqlTools is a generated GoMock package.
package mysqlTools

import (
	sql "database/sql"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockMysqlTools is a mock of MysqlTools interface
type MockMysqlTools struct {
	ctrl     *gomock.Controller
	recorder *MockMysqlToolsMockRecorder
}

// MockMysqlToolsMockRecorder is the mock recorder for MockMysqlTools
type MockMysqlToolsMockRecorder struct {
	mock *MockMysqlTools
}

// NewMockMysqlTools creates a new mock instance
func NewMockMysqlTools(ctrl *gomock.Controller) *MockMysqlTools {
	mock := &MockMysqlTools{ctrl: ctrl}
	mock.recorder = &MockMysqlToolsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockMysqlTools) EXPECT() *MockMysqlToolsMockRecorder {
	return m.recorder
}

// ChangeStmt mocks base method
func (m *MockMysqlTools) ChangeStmt(arg0 string, arg1 ...interface{}) (sql.Result, bool) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ChangeStmt", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// ChangeStmt indicates an expected call of ChangeStmt
func (mr *MockMysqlToolsMockRecorder) ChangeStmt(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangeStmt", reflect.TypeOf((*MockMysqlTools)(nil).ChangeStmt), varargs...)
}

// Close mocks base method
func (m *MockMysqlTools) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close
func (mr *MockMysqlToolsMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockMysqlTools)(nil).Close))
}

// Connect mocks base method
func (m *MockMysqlTools) Connect() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Connect")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Connect indicates an expected call of Connect
func (mr *MockMysqlToolsMockRecorder) Connect() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Connect", reflect.TypeOf((*MockMysqlTools)(nil).Connect))
}

// ExecCmd mocks base method
func (m *MockMysqlTools) ExecCmd(arg0 string, arg1 ...interface{}) sql.Result {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecCmd", varargs...)
	ret0, _ := ret[0].(sql.Result)
	return ret0
}

// ExecCmd indicates an expected call of ExecCmd
func (mr *MockMysqlToolsMockRecorder) ExecCmd(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecCmd", reflect.TypeOf((*MockMysqlTools)(nil).ExecCmd), varargs...)
}

// Query mocks base method
func (m *MockMysqlTools) Query(arg0 string, arg1 ...interface{}) func(bool) ([]sql.RawBytes, bool) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(func(bool) ([]sql.RawBytes, bool))
	return ret0
}

// Query indicates an expected call of Query
func (mr *MockMysqlToolsMockRecorder) Query(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockMysqlTools)(nil).Query), varargs...)
}

// QueryOneStmt mocks base method
func (m *MockMysqlTools) QueryOneStmt(arg0 string, arg1 ...interface{}) (sql.Row, bool) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryOneStmt", varargs...)
	ret0, _ := ret[0].(sql.Row)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// QueryOneStmt indicates an expected call of QueryOneStmt
func (mr *MockMysqlToolsMockRecorder) QueryOneStmt(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryOneStmt", reflect.TypeOf((*MockMysqlTools)(nil).QueryOneStmt), varargs...)
}

// SetConfig mocks base method
func (m *MockMysqlTools) SetConfig(arg0, arg1, arg2, arg3 string, arg4 int, arg5 string, arg6 bool) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetConfig", arg0, arg1, arg2, arg3, arg4, arg5, arg6)
	ret0, _ := ret[0].(bool)
	return ret0
}

// SetConfig indicates an expected call of SetConfig
func (mr *MockMysqlToolsMockRecorder) SetConfig(arg0, arg1, arg2, arg3, arg4, arg5, arg6 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetConfig", reflect.TypeOf((*MockMysqlTools)(nil).SetConfig), arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// SetErrLog mocks base method
func (m *MockMysqlTools) SetErrLog(arg0 string, arg1 ...interface{}) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "SetErrLog", varargs...)
}

// SetErrLog indicates an expected call of SetErrLog
func (mr *MockMysqlToolsMockRecorder) SetErrLog(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetErrLog", reflect.TypeOf((*MockMysqlTools)(nil).SetErrLog), varargs...)
}

// SetLogHandle mocks base method
func (m *MockMysqlTools) SetLogHandle(arg0 func(interface{})) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetLogHandle", arg0)
}

// SetLogHandle indicates an expected call of SetLogHandle
func (mr *MockMysqlToolsMockRecorder) SetLogHandle(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLogHandle", reflect.TypeOf((*MockMysqlTools)(nil).SetLogHandle), arg0)
}

// SetMaxConn mocks base method
func (m *MockMysqlTools) SetMaxConn(arg0 int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetMaxConn", arg0)
}

// SetMaxConn indicates an expected call of SetMaxConn
func (mr *MockMysqlToolsMockRecorder) SetMaxConn(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetMaxConn", reflect.TypeOf((*MockMysqlTools)(nil).SetMaxConn), arg0)
}

// SetSqlStatement mocks base method
func (m *MockMysqlTools) SetSqlStatement(arg0, arg1 string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetSqlStatement", arg0, arg1)
	ret0, _ := ret[0].(bool)
	return ret0
}

// SetSqlStatement indicates an expected call of SetSqlStatement
func (mr *MockMysqlToolsMockRecorder) SetSqlStatement(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetSqlStatement", reflect.TypeOf((*MockMysqlTools)(nil).SetSqlStatement), arg0, arg1)
}
